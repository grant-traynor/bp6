# BP6-643.004 Task Breakdown Review
## Session Selection & Switching UI

**Review Date:** 2026-02-14
**Reviewer:** Claude Sonnet 4.5
**Status:** ✅ APPROVED with Minor Recommendations

---

## Executive Summary

The task breakdown for bp6-643.004 is **well-structured and complete**. All 8 child tasks cover the necessary work to implement session selection and switching UI. Dependencies are correctly defined, and the implementation details are accurate.

### Overall Assessment
- **Completeness:** 95% - All major components covered
- **Accuracy:** 98% - Implementation details align with backend API
- **Dependencies:** 100% - Dependency graph is correct
- **Clarity:** 90% - Clear acceptance criteria for each task

---

## Task-by-Task Analysis

### ✅ bp6-643.004.1: Define SessionInfo TypeScript types and API contracts
**Status:** Well-defined
**Completeness:** Excellent

**Existing Implementation:**
- ✅ SessionInfo interface already exists (api.ts lines 166-173)
- ✅ PERSONA_ICONS already defined (api.ts lines 176-181)

**Gap Identified:**
The helper functions mentioned in the task notes don't exist yet:
```typescript
formatSessionRuntime(createdAt: number): string
getPersonaIcon(persona: string): string
```

**Recommendation:**
- Task should verify existing types are complete
- Add the helper functions as specified
- This task is mostly **validation + small additions**

**Estimated Effort:** 30 minutes (mostly validation)

---

### ✅ bp6-643.004.2: Implement session management Tauri API wrapper functions
**Status:** Well-defined
**Completeness:** Excellent

**Backend Verification:**
All Tauri commands exist and are registered:
- ✅ `list_active_sessions` (session.rs:717)
- ✅ `switch_active_session` (session.rs:747)
- ✅ `get_active_session_id` (session.rs:731)
- ✅ `terminate_session` (session.rs:787)

**Accuracy Check:**
The proposed TypeScript wrapper signatures match the Rust backend perfectly.

**Recommendation:**
- Implementation details are accurate
- Error handling pattern is appropriate
- Ready to implement as-is

**Estimated Effort:** 1 hour

---

### ✅ bp6-643.004.3: Create SessionItem component
**Status:** Well-defined
**Completeness:** Very Good

**Design Review:**
The component interface and UI structure are well thought out. The visual design matches the brutalist aesthetic.

**Potential Enhancement:**
Consider adding a `className` prop for additional styling flexibility:
```typescript
interface SessionItemProps {
  session: SessionInfo;
  isActive: boolean;
  beadTitle: string;
  onSelect: (sessionId: string) => void;
  onTerminate: (sessionId: string) => void;
  className?: string;  // ADD THIS
}
```

**Implementation Note:**
The task mentions "runtime updates every second (useEffect timer)" - this should use `setInterval` for live updates.

**Recommendation:**
- Add className prop (optional)
- Clarify that runtime should update reactively
- Otherwise ready to implement

**Estimated Effort:** 2 hours

---

### ✅ bp6-643.004.4: Create SessionList component
**Status:** Well-defined
**Completeness:** Very Good

**Design Review:**
Collapsible sidebar with polling is a solid approach.

**Concern: Polling vs Event-Driven**
The design specifies "poll every 5 seconds" but the backend emits events:
- `session-created`
- `session-terminated`
- `session-list-changed`
- `active-session-changed`

**Recommendation:**
**IMPORTANT:** Use event-driven updates instead of polling:
```typescript
useEffect(() => {
  let unlisten: UnlistenFn | undefined;

  onSessionListChanged((sessions) => {
    setSessionList(sessions);
  }).then(fn => { unlisten = fn; });

  return () => { unlisten?.(); };
}, []);
```

This is more efficient and provides real-time updates without 5-second lag.

**Bead Title Lookup:**
The task mentions "Look up bead titles from parent/context" but doesn't specify the mechanism. Need to clarify if:
1. Pass beads map from App.tsx as prop
2. Use React Context
3. Fetch via API

**Recommendation:**
- **Replace polling with event subscription** (CRITICAL)
- Clarify bead title lookup mechanism
- Otherwise implementation is sound

**Estimated Effort:** 3 hours

---

### ⚠️ bp6-643.004.5: Implement session history loading from JSONL logs
**Status:** Well-defined with concerns
**Completeness:** Good but needs refinement

**Potential Issues:**

1. **File System Access Limitation:**
   Tauri's `readDir` and `readTextFile` may have permission issues reading from `~/.bp6/sessions/`. The task should verify:
   - Tauri allowlist configuration for fs scope
   - Whether the app has permission to read this directory

2. **JSONL Schema Alignment:**
   The ConversationEntry interface is incomplete. Need to reference bp6-643.002 for the full schema:
   ```typescript
   export interface ConversationEntry {
     event_type: 'message' | 'chunk' | 'command' | 'stderr';
     timestamp: number;
     session_id: string;
     bead_id: string;
     persona: string;
     role?: 'user' | 'assistant';
     content: string;
     metadata?: Record<string, any>;
   }
   ```

3. **Filename Pattern:**
   Task mentions `<session-id>-*.jsonl` but bp6-643.002 design uses:
   ```
   .bp6/sessions/<bead-id>/<session-id>.jsonl
   ```
   (single file, not multiple)

4. **Better Approach:**
   Since the backend already manages these logs, consider adding a Tauri command:
   ```rust
   #[tauri::command]
   pub fn load_session_history(session_id: String, bead_id: String)
       -> Result<Vec<Message>, String>
   ```
   This avoids frontend file system complexity.

**Recommendation:**
- **CRITICAL:** Verify JSONL file structure with bp6-643.002
- **STRONGLY CONSIDER:** Add backend Tauri command instead of frontend fs access
- Update ConversationEntry interface to match bp6-643.002 schema
- Verify Tauri fs permissions

**Estimated Effort:** 3-4 hours (or 2 hours if using backend command)

---

### ✅ bp6-643.004.6: Integrate SessionList into ChatDialog layout
**Status:** Well-defined
**Completeness:** Good

**Layout Approach:**
The flex layout is correct and aligns with modern patterns.

**Missing Consideration:**
The task should mention handling the case where:
- ChatDialog is opened for a NEW session (not yet in the session list)
- How to initialize `sessionId` state when dialog opens

**Current ChatDialog State:**
```typescript
const [sessionId, setSessionId] = useState<string | null>(null);
```

**Recommendation:**
Add initialization logic:
```typescript
useEffect(() => {
  if (isOpen && !sessionId) {
    // Either get active session or use the one being started
    getActiveSessionId().then(id => setSessionId(id));
  }
}, [isOpen]);
```

**Estimated Effort:** 2 hours

---

### ✅ bp6-643.004.7: Implement session switching and termination handlers
**Status:** Well-defined
**Completeness:** Excellent

**Handler Logic:**
The implementation details are comprehensive and handle edge cases well:
- Loading states ✅
- Error handling ✅
- Auto-switch when terminating active session ✅
- Confirmation dialogs ✅

**Enhancement Suggestion:**
Consider using a better confirmation dialog than `window.confirm`:
```typescript
// Use a custom modal component for better UX
const handleSessionTerminate = async (sessionId: string) => {
  setConfirmDialog({
    title: 'Terminate Session',
    message: `Stop the agent and close session ${sessionId}?`,
    onConfirm: () => doTerminate(sessionId),
  });
};
```

**Recommendation:**
- Implementation is solid as-is
- Consider custom confirm dialog (optional enhancement)
- Ready to implement

**Estimated Effort:** 3 hours

---

### ✅ bp6-643.004.8: Add session list styles and responsive layout
**Status:** Well-defined
**Completeness:** Very Good

**CSS Review:**
The styles are comprehensive and follow modern CSS practices. Brutalist theme integration is correct.

**Missing Styles:**
1. Empty state styling for "No active sessions"
2. Collapsed state icon-only view styles
3. Loading state skeleton/shimmer

**Responsive Strategy:**
The responsive approach is good but should include specific breakpoints:
```css
@media (max-width: 768px) {
  .session-list {
    position: absolute;
    z-index: 100;
    height: 100%;
  }
  .session-list.collapsed {
    transform: translateX(-100%);
  }
}
```

**Recommendation:**
- Add missing state styles (empty, loading)
- Define specific breakpoints for responsive behavior
- Otherwise comprehensive

**Estimated Effort:** 2 hours

---

## Dependency Graph Analysis

The dependency graph is **correct and optimal**:

```
bp6-643.004.1 (Types)
    ├─> bp6-643.004.2 (API Wrappers)
    ├─> bp6-643.004.3 (SessionItem)
    └─> bp6-643.004.5 (History Loading)

bp6-643.004.2 + bp6-643.004.3
    └─> bp6-643.004.4 (SessionList)

bp6-643.004.2 + bp6-643.004.5
    └─> bp6-643.004.7 (Handlers)

bp6-643.004.4 + bp6-643.004.7
    └─> bp6-643.004.6 (Integration)

bp6-643.004.6
    └─> bp6-643.004.8 (Styles)
```

**Parallelization Opportunities:**
- Wave 1: bp6-643.004.1 alone
- Wave 2: bp6-643.004.2, bp6-643.004.3, bp6-643.004.5 in parallel
- Wave 3: bp6-643.004.4, bp6-643.004.7 in parallel
- Wave 4: bp6-643.004.6
- Wave 5: bp6-643.004.8

---

## Missing Considerations

### 1. **Session Creation Integration**
The tasks focus on viewing/switching existing sessions but don't cover:
- How to create a NEW session from ChatDialog
- "New Session" button in SessionList?
- Or is session creation only from WBS tree context menu?

**Recommendation:** Clarify session creation flow or add task if needed.

### 2. **Session Metadata Display**
Consider displaying additional session metadata:
- Timestamp of last activity
- Number of messages exchanged
- Session health status (stalled, active, waiting)

**Recommendation:** Optional enhancement for future iteration.

### 3. **Keyboard Shortcuts**
Power users would benefit from keyboard shortcuts:
- Ctrl+1-9 to switch to session N
- Ctrl+W to close session
- Ctrl+N for new session

**Recommendation:** Document in future UX refinement feature.

### 4. **Session Persistence**
What happens when the app closes?
- Are sessions killed or preserved?
- On restart, can user resume sessions?

**Recommendation:** Should be covered by bp6-643.001 backend, verify alignment.

---

## Integration with Other Features

### Dependency on bp6-643.001 ✅
All Tauri commands exist and are properly registered.

### Dependency on bp6-643.002 ⚠️
History loading assumes JSONL structure - **needs alignment check**.

### Dependency on bp6-643.003 ✅
PERSONA_ICONS and SessionInfo types already exist and are aligned.

### Dependency on Epic 6dk ✅
PersonaType and BackendId enums are correctly referenced.

---

## Recommended Adjustments

### High Priority
1. **bp6-643.004.4:** Replace polling with event-driven updates (use `onSessionListChanged`)
2. **bp6-643.004.5:** Verify JSONL file structure matches bp6-643.002 implementation
3. **bp6-643.004.5:** Consider adding backend Tauri command for history loading

### Medium Priority
4. **bp6-643.004.1:** Clarify that task is mostly validation since types exist
5. **bp6-643.004.6:** Add session ID initialization logic
6. **bp6-643.004.8:** Add styles for empty/loading states

### Low Priority (Nice to Have)
7. Consider adding session creation UI task
8. Consider keyboard shortcuts for future iteration
9. Replace `window.confirm` with custom modal component

---

## Estimated Total Effort

| Task | Estimated Time |
|------|----------------|
| bp6-643.004.1 | 0.5 hours |
| bp6-643.004.2 | 1 hour |
| bp6-643.004.3 | 2 hours |
| bp6-643.004.4 | 3 hours |
| bp6-643.004.5 | 3-4 hours |
| bp6-643.004.6 | 2 hours |
| bp6-643.004.7 | 3 hours |
| bp6-643.004.8 | 2 hours |
| **Total** | **16.5-17.5 hours** |

With 2-3 parallel agents: **~6-8 hours wall time**

---

## Final Verdict

**APPROVED** ✅

The task breakdown is solid and implementable. The three high-priority adjustments should be made before starting implementation:

1. Use event-driven updates instead of polling
2. Align history loading with bp6-643.002
3. Consider backend command for history loading

With these adjustments, the breakdown is **production-ready** and provides clear, actionable tasks for implementation.

---

## Next Steps

1. Address high-priority recommendations
2. Update task notes for bp6-643.004.4 and bp6-643.004.5
3. Proceed with implementation using wave-based parallelization
4. Start with bp6-643.004.1 (types validation + helpers)
